# Part B2

Strategies for keeping count:

1. iterate through the entire set across all stripes each time a count is needed;
2. keep a per-stripe counter and add up counters from every stripe when queried;
3. keep a global (i.e., one single) counter that gets updated when a string is added.

Questions:

- What are the advantages and disadvantages of each of these approaches?
- Can you think of query patterns where one works better than another?

Because the strategies described above are highly dependent on the specific implementation, I will
be describing my implementation design for each strategy before evaluating its pros and cons.

For Approach 1, the implementation I have in mind is that we iterate through all stripes of the set,
and we count the size of each stripe by calling len() on the map. This means that we would need to
hold a read lock on whichever stripe we are currently counting. 

For Approach 2, the implementation I have in mind is that for each stripe of the set, we maintain a
counter in the StringSetStripe data structure. This counter would be protected using the same mutex
that is in the StringSetStripe structure, and it needs to be incremented in the Add function. When
the counter is incremented in the Add function, we must hold the write lock on the stripe, and when
the counter is being read in the Count function, we must hold the read lock on the stripe.

In comparison, both Approach 1 and 2 requires that when we are counting, we need to hold a read lock 
on the stripe that we are currently accessing. Both of them also have the disadvantage that when 
Count() returns, the returned value is not guaranteed to reflect the size of the set at that moment 
(this is because some stripes may have been modified after being counted). But Approach 2 has the 
additional overhead of incrementing the counter in the Add function. This means that Approach 1 would 
perform better for query patterns that have more Add operations.

For Approach 3, using an atomic counter would allow us to avoid using locks on the global counter. It
would also eliminate the need to iterate through all the stripes and count each of them, hence improving
the performance of the Count operation. When we are reading the global counter, we don't even need to
lock any of the stripes, which means that the Count operation has minimal interference with the Add
operation (the only interference occurs at the level of the atomic counter). Like Approach 2, however,
Approach 3 does have the additional work of incrementing the atomic counter in the Add operation. Hence,
compared to Approach 1 and Approach 2, Approach 3 has the best performance for the Count operation and 
would perform better for query patterns that have a lot of Count operations. Approach 3 also has the
disadvantage that when the Count operation returns, the returned value does not necessarily reflect
the size of the set at that moment (because the stripes may have been modified but haven't updated the
global counter).

# Part C3

Sub-benchmark: adds+counts
- LockedStringSet/adds+counts:             879.8 ns/op
- StripedStringSet/adds+counts/stripes=2:  180.8 ns/op

Discussion:
Splitting the string set into 2 stripes significantly boosted performance in adds+counts. This is
expected, because when we have 2 stripes in the set, operations in one stripe would not interfere
with operations in the other stripe. Hence, we could have Add operations run in parallel on the set.

Sub-benchmark: scans:serial
- LockedStringSet/scans:serial:             506476748 ns/op
- StripedStringSet/scans:serial/stripes=2:  306903268 ns/op

Sub-benchmark: scans:parallel
- LockedStringSet/scans:parallel:             166634118 ns/op
- StripedStringSet/scans:parallel/stripes=2:  118152799 ns/op